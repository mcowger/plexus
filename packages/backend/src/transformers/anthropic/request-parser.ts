import { UnifiedChatRequest, UnifiedMessage } from '../../types/unified';
import { getThinkLevel } from '../utils';
import { convertAnthropicContent } from './content-mapper';
import { convertAnthropicToolsToUnified } from './tool-mapper';

/**
 * Parses an Anthropic API request and converts it to unified format.
 *
 * Key transformations:
 * - System message extraction from separate 'system' field
 * - Content array parsing (text, image, tool_use, tool_result, thinking)
 * - Tool choice normalization
 * - Thinking configuration mapping
 */
export async function parseAnthropicRequest(input: any): Promise<UnifiedChatRequest> {
  const messages: UnifiedMessage[] = [];

  // Anthropic uses a separate 'system' field; we merge it as a 'system' role message.
  if (input.system) {
    if (typeof input.system === 'string') {
      messages.push({ role: 'system', content: input.system });
    } else if (Array.isArray(input.system)) {
      const systemContent = input.system
        .filter((part: any) => part.type === 'text')
        .map((part: any) => ({
          type: 'text' as const,
          text: part.text,
          cache_control: part.cache_control,
        }));
      messages.push({ role: 'system', content: systemContent });
    }
  }

  if (input.messages) {
    for (const msg of input.messages) {
      if (msg.role === 'user' || msg.role === 'assistant') {
        if (typeof msg.content === 'string') {
          messages.push({ role: msg.role, content: msg.content });
        } else if (Array.isArray(msg.content)) {
          const unifiedMsg: UnifiedMessage = { role: msg.role, content: '' };

          // Handle tool results sent by the user
          const toolResults = msg.content.filter((c: any) => c.type === 'tool_result');
          if (toolResults.length > 0 && msg.role === 'user') {
            for (const tool of toolResults) {
              messages.push({
                role: 'tool',
                content:
                  typeof tool.content === 'string' ? tool.content : JSON.stringify(tool.content),
                tool_call_id: tool.tool_use_id,
                cache_control: tool.cache_control,
              });
            }
            const otherParts = msg.content.filter((c: any) => c.type !== 'tool_result');
            if (otherParts.length > 0) {
              messages.push({
                role: 'user',
                content: convertAnthropicContent(otherParts),
              });
            }
            continue;
          }

          // Handle tool calls generated by the assistant
          const toolUses = msg.content.filter((c: any) => c.type === 'tool_use');
          if (toolUses.length > 0 && msg.role === 'assistant') {
            unifiedMsg.tool_calls = toolUses.map((t: any) => ({
              id: t.id,
              type: 'function',
              function: {
                name: t.name,
                arguments: JSON.stringify(t.input || {}),
              },
            }));
          }

          // Handle Thinking/Reasoning content (Claude 3.7+ feature)
          const thinkingPart = msg.content.find((c: any) => c.type === 'thinking');
          if (thinkingPart && msg.role === 'assistant') {
            unifiedMsg.thinking = {
              content: thinkingPart.thinking,
              signature: thinkingPart.signature,
            };
          }

          // Handle standard text/image parts
          const contentParts = msg.content.filter(
            (c: any) => c.type !== 'tool_use' && c.type !== 'tool_result' && c.type !== 'thinking'
          );
          if (contentParts.length > 0) {
            unifiedMsg.content = convertAnthropicContent(contentParts);
          } else if (unifiedMsg.tool_calls || unifiedMsg.thinking) {
            unifiedMsg.content = null;
          }

          messages.push(unifiedMsg);
        }
      }
    }
  }

  const result: UnifiedChatRequest = {
    messages,
    model: input.model,
    max_tokens: input.max_tokens,
    temperature: input.temperature,
    stream: input.stream,
    tools: input.tools ? convertAnthropicToolsToUnified(input.tools) : undefined,
    tool_choice: input.tool_choice,
  };

  // Map Thinking/Reasoning Configuration
  if (input.thinking) {
    result.reasoning = {
      effort: getThinkLevel(input.thinking.budget_tokens),
      max_tokens: input.thinking.budget_tokens,
      enabled: input.thinking.type === 'enabled',
    };
  }

  // Strict Tool Choice Mapping
  if (input.tool_choice) {
    if (typeof input.tool_choice === 'object' && input.tool_choice.type === 'tool') {
      result.tool_choice = {
        type: 'function',
        function: { name: input.tool_choice.name },
      };
    } else if (typeof input.tool_choice === 'object' && input.tool_choice.type) {
      result.tool_choice = input.tool_choice.type;
    }
  }

  return result;
}
