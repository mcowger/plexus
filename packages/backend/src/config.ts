import { z } from 'zod';
import fs from 'fs';
import yaml from 'yaml';
import path from 'path';
import { logger } from './utils/logger';

// --- Zod Schemas ---

const PricingRangeSchema = z.object({
  lower_bound: z.number().min(0).default(0),
  upper_bound: z.number().default(Infinity),
  input_per_m: z.number().min(0),
  output_per_m: z.number().min(0),
});

const PricingSchema = z.discriminatedUnion('source', [
  z.object({
    source: z.literal('openrouter'),
    slug: z.string(),
  }),
  z.object({
    source: z.literal('defined'),
    range: z.array(PricingRangeSchema).min(1),
  }),
  z.object({
    source: z.literal('simple'),
    input: z.number().min(0),
    output: z.number().min(0),
    cached: z.number().min(0).optional(),
  }),
]);

const ModelProviderConfigSchema = z.object({
  pricing: PricingSchema.default({
    source: 'simple',
    input: 0,
    output: 0,
  }),
});

const ProviderConfigSchema = z.object({
  type: z.string(),
  display_name: z.string().optional(),
  api_base_url: z.string().url(),
  api_key: z.string().optional(),
  models: z.union([
    z.array(z.string()),
    z.record(z.string(), ModelProviderConfigSchema)
  ]).optional(),
  headers: z.record(z.string()).optional(),
  extraBody: z.record(z.any()).optional(),
});

const ModelTargetSchema = z.object({
  provider: z.string(),
  model: z.string(),
});

const ModelConfigSchema = z.object({
  selector: z.enum(['random', 'cost', 'latency', 'usage']).optional(),
  targets: z.array(ModelTargetSchema),
});

const PlexusConfigSchema = z.object({
  providers: z.record(z.string(), ProviderConfigSchema),
  models: z.record(z.string(), ModelConfigSchema),
});

export type PlexusConfig = z.infer<typeof PlexusConfigSchema>;
export type ProviderConfig = z.infer<typeof ProviderConfigSchema>;
export type ModelConfig = z.infer<typeof ModelConfigSchema>;
export type ModelTarget = z.infer<typeof ModelTargetSchema>;

// --- Loader ---

let currentConfig: PlexusConfig | null = null;
let currentConfigPath: string | null = null;
let configWatcher: fs.FSWatcher | null = null;

function logConfigStats(config: PlexusConfig) {
    const providerCount = Object.keys(config.providers).length;
    logger.info(`Loaded ${providerCount} Providers:`);
    Object.entries(config.providers).forEach(([name, provider]) => {
      let modelCount = 0;
      if (Array.isArray(provider.models)) {
        modelCount = provider.models.length;
      } else if (provider.models) {
        modelCount = Object.keys(provider.models).length;
      }
      logger.info(`  - ${name}: ${modelCount} models`);
    });

    const aliasCount = Object.keys(config.models).length;
    logger.info(`Loaded ${aliasCount} Model Aliases:`);
    Object.entries(config.models).forEach(([name, alias]) => {
      const targetCount = alias.targets.length;
      logger.info(`  - ${name}: ${targetCount} targets`);
    });
}

export function validateConfig(yamlContent: string): PlexusConfig {
  const parsed = yaml.parse(yamlContent);
  return PlexusConfigSchema.parse(parsed);
}

async function parseConfigFile(filePath: string): Promise<PlexusConfig> {
  const file = Bun.file(filePath);
  const fileContents = await file.text();
  const config = validateConfig(fileContents);
  logConfigStats(config);
  return config;
}

function setupWatcher(filePath: string) {
    if (configWatcher) return;
    
    logger.info(`Watching configuration file: ${filePath}`);
    let debounceTimer: NodeJS.Timeout | null = null;

    try {
        configWatcher = fs.watch(filePath, (eventType) => {
            if (eventType === 'change') {
                if (debounceTimer) clearTimeout(debounceTimer);
                
                debounceTimer = setTimeout(async () => {
                    logger.info('Configuration file changed, reloading...');
                    try {
                        const newConfig = await parseConfigFile(filePath);
                        currentConfig = newConfig;
                        logger.info('Configuration reloaded successfully');
                    } catch (error) {
                        logger.error('Failed to reload configuration', { error });
                         if (error instanceof z.ZodError) {
                             logger.error('Validation errors:', error.errors);
                         }
                    }
                }, 100);
            }
        });
    } catch (err) {
        logger.error('Failed to setup config watcher', err);
    }
}

export async function loadConfig(configPath?: string): Promise<PlexusConfig> {
  if (currentConfig && !configPath) return currentConfig;

  // Default path assumes running from packages/backend, but we want it relative to project root
  const projectRoot = path.resolve(process.cwd(), '../../');
  const defaultPath = path.resolve(projectRoot, 'config/plexus.yaml');
  const finalPath = configPath || process.env.CONFIG_FILE || defaultPath;
  
  logger.info(`Loading configuration from ${finalPath}`);

  const file = Bun.file(finalPath);
  if (!(await file.exists())) {
    logger.error(`Configuration file not found at ${finalPath}`);
    throw new Error(`Configuration file not found at ${finalPath}`);
  }

  try {
    currentConfig = await parseConfigFile(finalPath);
    currentConfigPath = finalPath;
    logger.info('Configuration loaded successfully');
    
    setupWatcher(finalPath);
    
    return currentConfig;
  } catch (error) {
    if (error instanceof z.ZodError) {
      logger.error('Configuration validation failed', { errors: error.errors });
    }
    throw error;
  }
}

export function getConfig(): PlexusConfig {
    if (!currentConfig) {
        throw new Error("Configuration not loaded. Call loadConfig() first.");
    }
    return currentConfig;
}

export function getConfigPath(): string | null {
    return currentConfigPath;
}

export function setConfigForTesting(config: PlexusConfig) {
    console.log("setConfigForTesting called with keys:", Object.keys(config.providers));
    currentConfig = config;
}